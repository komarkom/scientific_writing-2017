## Описание метода решения
В результате, было решены выбрать сервис-ореинтированную архитектуру и для синхронизации потоков взята за основу модель сообщений. Сервис ореинтированная архитектура представляет собой разумный баланс: её модули более функциональны чем у микросервисной, но всё ещё не так сильно связаны, как у монолитной.

Основная идея - взаимодействие потоков через сообщения. MessageSystem — объект для обмена данными. Address и Abonent. Аналогия с почтой. Message — иерархия наследования сообщений. AddressService. В идеале, абоненты могут находиться на разных физических машинах.

На иллюстрации вы можете увидеть принцип работы. Существуют два сервиса: Frontend и AccountService каждый из которых работает в своём потоке. Всё обращение между ними происходит через MessageSystem - при необходимости в неё передаются объекты с запросами данных или самими данными, которые добавляются в очередь сообщений каждого сервиса, а при возможности обрабатываются. Этот вариант работы называется асинхронным многопоточным.

![Пример работы системы сообщений](https://github.com/moevm/scientific_writing-2017/blob/ZaborovskiyEV/2303/ZaborovskiyEV/image/MessageSystem.png)

Рисунок 1 – Пример работы системы сообщений

### Основной функционал системы
Разработанный код является основой для многопоточной системы, которая ореинтирована на добавление к себе различных модулей (сервисов) для решения задач. 

В реализованном мною примере это система использоуется в качестве базы для серверной части многопоточной игры для чего были подготовлены сервисы: аккаунтов (работа с СУБД посредством Object-Relational Mapping), сетевого транспорта (передача информации игрокам), игровой логики, AI (элементарые мобы).

Клиентская часть была выполнена на Unity3d с использованием C#; она и сетевая часть не являются предметом этой статьи.

### Архитектура программной реализации
![Пример архитектуры](https://github.com/moevm/scientific_writing-2017/blob/ZaborovskiyEV/2303/ZaborovskiyEV/image/Architecture.png)

Рисунок 2 – Архитектура примера на основе системы

Архитектура представляет собой набор основных игровых сервисов, каждый из которых выполняется в отдельном потоке (в действующей системе инстансов одного сервиса может быть несколько для масштабирования). 
####Transport Service
Сервис, который отвечает за свзяь (отправку и получение данных) клиента (игрока) и сервера (игровой системы).
####GameLogic Service
Сервис, в котором находится базовая игровая логика: физика, списки объектов, различные таймеры и триггеры событий. Именно в этот сервис отправляются сообщения о перемещении или атаках.
####Accounts Service
Сервис, который записывает и запрашивает информацию в СУБД. Отвечает за загрузку и сохранение игрового прогресса пользователей.
####AI Service
Сервис, который обращаясь к GameLogic Service опредеяет поведение игровых сущностей, не контролируемых игроками.
Линии представляют собой основные каналы отправки и получения сообщений.

### Тестирование
В основном, базовая система покрыта лишь unit тестами направленными на проверку основных функций: отправка и получение сообщений. 

Основной интерес представляют тесты уже построенного примера сервера игры.

Для примера выполнялось нагрузочное тестирование для определения оптимального числа объектов игровой логики (использовались эмуляторы активности нескольких сценариев игрока); проверка маршрутизации сообщений между инстансами игровой логики для потокобезопасных операций над игровыми объектами; поиск пути для ботов и стресс тесты на поведение системы при отключении части модулей.

### Используемые технологи
Разработка велась в Intellij Idea с плагинами для тестирования и version control system (GIT). Код был написан на языке Java, используется СУБД MySQL.

Для тестирования используются библиотека JUnit. Она позволяют тестировать отдельные модули и методы системы, проверяя целостность работы, после обновлений.

В качестве io фреймворка был выбран Netty, как уже устоявшееся решения для сетевых приложений.

С целью упрощения развёртывания системы был подготовлен docker образ. Это упрощает и ускоряет перезапуск после критической ошибки, а также позволяет каждому иметь одинаковую среду для тестирования и разработки.

## Источники
1. https://habrahabr.ru/company/mailru/blog/259125/
