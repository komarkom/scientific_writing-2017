Every more or less complex system possesses the means to report its
state changes. Linux, for example, has *syslog* - a common log sink
[@rfc:5424]. And */proc/kmsg* [@man:proc; @LDD:2005] in conjunction with
*dmesg* [@man:dmesg] is a good example of flexible and loosely coupled
kernel feedback mechanism. Those mechanisms provide the interface to
inspect system and process logs, in the aggregate - which is extremely
illustrative. Late versions of *dmesg* also have the ability to
highlight its output. Logs are, by their nature, reactive - they are
generated by an actor (which is in our case a process or an individual
thread) at the correct moment of a certain event. This property is the
main reason why logs are so useful for debug and observation purposes -
the collection of logs from different sources is being constructed in
the correct chronological order. For the sake of deferred examination
*syslog*, */proc/kmsg* and its clients employ timestamps [@rfc:5424],
which is a common practice for mechanisms of this sort.

Not all system information stack can equally provide reactivity, but
this can be emulated (poorly sometimes). For example, Linux provides the
ability for user to poll current memory state through */proc*
pseudo-file system [@man:proc; @Kerrisk:2010], but there are currently
no events, which reflect memory consumption jumps or high increase in
page swapping. The reason for this is that the techniques for monitoring
memory state vary greatly from user to user. For example, there is no
absolute **very high** value of memory consumption increase - this
depends on a concrete Linux setup. In other words, this is a high-level
functionality, a delicately tuneable one.

ROS is a robotics middleware, which encapsulates underlying operating
system abstractions and provides mature development ecosystem. It
implements several different styles of communication, one of which can
be characterized as message passing, publisher-subscriber paradigm
[@ros:concepts]. This workflow is based on topics (discussed below), and
in this paper will later be referred to as reactive. This style of
communication is of interest to this work, because, as was mentioned
earlier, message-based diagnostics is intuitive and descriptive. The
main unit in ROS computaion graph is *node*, which is represented by a
system process [@ros:nodes]. *Topic* is a typical tool for observing
another node changes. It is a unidirectional named transport, based on
standard TCP or UDP stack [@ros:topics]. As will be shown later in this
text, there is currently no decent reactive system monitor for ROS - a
tool which will be flexible and vivid enough to cover valuable system
and node changes altogether.

This paper attempts to describe the requirements for such a set of tools
and denotes the way of building this system. The main purpose of this
work is to present a flexible and responsive tool for monitoring system
and individual node state in ROS.
